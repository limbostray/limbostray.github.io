{"meta":{"title":"Lan An's blog","subtitle":"城市慷慨亮整夜光,如同少年不惧岁月长","description":"","author":"蓝桉","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Go语言学习笔记","slug":"Go语言学习笔记","date":"2020-02-10T03:23:55.000Z","updated":"2020-02-11T09:18:06.493Z","comments":true,"path":"2020/02/10/Go语言学习笔记/","link":"","permalink":"http://yoursite.com/2020/02/10/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"Go语言学习笔记Go语言简介Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。","text":"Go语言学习笔记Go语言简介Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。 Go语言的特性Go 语言从本质上（程序和结构方面）来实现并发编程。 因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。 在传统的面向对象语言中，使用面向对象编程技术显得非常臃肿，它们总是通过复杂的模式来构建庞大的类型层级，这违背了编程语言应该提升生产力的宗旨。 函数是 Go 语言中的基本构件，它们的使用方法非常灵活。在第六章，我们会看到 Go 语言在函数式编程方面的基本概念。 Go 语言使用静态类型，所以它是类型安全的一门语言，加上通过构建到本地代码，程序的执行速度也非常快。 作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。 Go 语言其实也有一些动态语言的特性（通过关键字 var），所以它对那些逃离 Java 和 .Net 世界而使用 Python、Ruby、PHP 和 JavaScript 的开发者们也具有很大的吸引力。 Go 语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！ 简化问题，易于学习 内存管理，简洁语法，易于使用 快速编译，高效开发 高效执行 并发支持，轻松驾驭 静态类型 标准类库，规范统一 易于部署 文档全面 免费开源 垃圾回收器Go 拥有简单却高效的标记-清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。目前 gccgo 还没有回收器，同时适用 gc 和 gccgo 的新回收器正在研发中。使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。 Go 的可执行文件都比相对应的源代码文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。当然，在部署到数量巨大的集群时，较大的文件体积也是比较头疼的问题。但总的来说，Go 的部署工作还是要比 Java 和 Python 轻松得多。因为 Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样在各种不同版本的依赖文件之间混淆。 格式化代码Go 开发团队不想要 Go 语言像许多其它语言那样总是在为代码风格而引发无休止的争论，浪费大量宝贵的开发时间，因此他们制作了一个工具：go fmt（gofmt）。这个工具可以将你的源代码格式化成符合官方统一标准的风格，属于语法风格层面上的小型重构。遵循统一的代码风格是 Go 开发中无可撼动的铁律，因此你必须在编译或提交版本管理系统之前使用 gofmt 来格式化你的代码。在命令行输入gofmt –w program.go会格式化该源文件的代码然后将格式化后的代码覆盖原始内容 与其它语言进行交互（待填坑）与C语言交互（待填坑） 与C++交互（待填坑） 文件名、关键字与标识符有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头，然后紧跟着 0 个或多个字符或 Unicode 数字，如：X56、group1、_x23、i、өԑ12。_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 下面列举了 Go 代码中会使用到的 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 包的概念，导入包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。 你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 标准库 在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。 Go 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包。 函数这是定义一个函数最简单的格式： 1func functionName() 你可以在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型。 main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 undefined: main.main。main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误： 1func main must have no arguments and no return values results. Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成。 注释单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。 多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 数据类型与声明变量（或常量）包含数据，这些数据可以有不同的数据类型，简称类型。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。 类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。 结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。 下面是我学习用写的一个程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package mainimport &quot;fmt&quot;&#x2F;&#x2F; Go语言推荐使用驼峰式命名&#x2F;&#x2F; var studentName string&#x2F;&#x2F;声明变量&#x2F;&#x2F;var a string&#x2F;&#x2F;var b int&#x2F;&#x2F;var c bool&#x2F;&#x2F;批量声明var ( a string &#x2F;&#x2F; &quot;&quot;空字符串 b int &#x2F;&#x2F; 0 c bool &#x2F;&#x2F; false)&#x2F;&#x2F;常量const pi &#x3D; 3.1415926const e &#x3D; 2.7182const ( statusOK &#x3D; 200 notFound &#x3D; 404)&#x2F;&#x2F;批量声明常量时如果没有赋值，默认和上一行一样const ( n1 &#x3D; 100 n2 n3)&#x2F;&#x2F;const中iota第一次出现时被重置为0，之后没新增一行const都会递增，类似枚举const ( a1 &#x3D; iota &#x2F;&#x2F; 0 a2 &#x2F;&#x2F; 1 a3 &#x2F;&#x2F; 2 a4 &#x2F;&#x2F; 3)const ( b1 &#x3D; iota &#x2F;&#x2F; 0 b2 &#x2F;&#x2F; 1 _ &#x2F;&#x2F; 2 b3 &#x2F;&#x2F; 3)&#x2F;&#x2F;插队const ( c1 &#x3D; iota &#x2F;&#x2F; 0 c2 &#x3D; 100 &#x2F;&#x2F; 100 c3 &#x3D; iota &#x2F;&#x2F; 2 c4 &#x2F;&#x2F; 3)&#x2F;&#x2F;多个常量声明在一行const ( d1, d2 &#x3D; iota + 1, iota + 2 &#x2F;&#x2F;d1:1, d2:2 d3, d4 &#x3D; iota + 1, iota + 2 &#x2F;&#x2F;d3:2, d4:3)&#x2F;&#x2F;定义数量级const ( _ &#x3D; iota KB &#x3D; 1 &lt;&lt; (10 * iota) MB &#x3D; 1 &lt;&lt; (10 * iota) GB &#x3D; 1 &lt;&lt; (10 * iota) TB &#x3D; 1 &lt;&lt; (10 * iota) PB &#x3D; 1 &lt;&lt; (10 * iota))func main() &#123; a &#x3D; &quot;理想&quot; b &#x3D; 16 c &#x3D; true &#x2F;&#x2F;Go语言中非全局变量变量声明必须使用，否则编译不过 fmt.Print(c) &#x2F;&#x2F;在终端中输出要打印的内容 fmt.Println() fmt.Printf(&quot;name:%s\\n&quot;,a) &#x2F;&#x2F; %s:占位符 fmt.Println(b) &#x2F;&#x2F; 打印完自动加一个换行符 &#x2F;&#x2F;声明变量同时赋值 var s1 string &#x3D; &quot;whb&quot; fmt.Println(s1) &#x2F;&#x2F;类型推导（根据值判断该变量是什么类型） var s2 &#x3D; &quot;20&quot; fmt.Println(s2) &#x2F;&#x2F;简短变量声明，只能在函数内使用 s3 :&#x3D; &quot;哈哈哈&quot; fmt.Println(s3) &#x2F;&#x2F;匿名变量 &#x2F;&#x2F;_&#x2F;&#x2F;注意事项:&#x2F;&#x2F;1.函数外每个语句必须以关键字开始(var, const, func)&#x2F;&#x2F;2. :&#x3D;不能用于函数外&#x2F;&#x2F;3. _多用于占位，表示忽略值 fmt.Println(&quot;注意事项:\\n1.函数外每个语句必须以关键字开始(var, const, func)\\n2. :&#x3D;不能用于函数外\\n3. _多用于占位，表示忽略值&quot;)&#125; Go程序的一般结构Go 程序的结构顺序如下： 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。 如果当前包是 main 包，则定义 main 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。 Go 程序的执行（程序启动）顺序如下： 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。 类型转换在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）： 1valueOfTypeB &#x3D; typeB(valueOfTypeA) 类型 B 的值 = 类型 B(类型 A 的值) 示例： 12a :&#x3D; 5.0b :&#x3D; int(a) init函数变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。 每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。 一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。 示例：init.go 123456789package transimport &quot;math&quot;var Pi float64func init() &#123; Pi &#x3D; 4 * math.Atan(1) &#x2F;&#x2F; init() function computes Pi&#125; 在它的 init 函数中计算变量 Pi 的初始值。 示例：user_init.go 中导入了包 trans（需要init.go目录为./trans/init.go）并且使用到了变量 Pi： 123456789101112package mainimport ( &quot;fmt&quot; &quot;.&#x2F;trans&quot;)var twoPi &#x3D; 2 * trans.Pifunc main() &#123; fmt.Printf(&quot;2*Pi &#x3D; %g\\n&quot;, twoPi) &#x2F;&#x2F; 2*Pi &#x3D; 6.283185307179586&#125; 基本类型","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"http://yoursite.com/tags/Go/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Arch-Linux-Install-Advanced","slug":"Arch-Linux-Install-Advanced","date":"2020-01-26T12:33:56.000Z","updated":"2020-02-11T09:18:06.493Z","comments":true,"path":"2020/01/26/Arch-Linux-Install-Advanced/","link":"","permalink":"http://yoursite.com/2020/01/26/Arch-Linux-Install-Advanced/","excerpt":"Arch Linux 折腾日常之基本系统的配置和KDE桌面环境的安装进入刚刚安装的 Arch Linux 使用root登录 联网 有线和USB网络共享 1dhcpcd &lt;网卡型号&gt; 无线 12wifi-menudhcpcd &lt;网卡型号&gt;","text":"Arch Linux 折腾日常之基本系统的配置和KDE桌面环境的安装进入刚刚安装的 Arch Linux 使用root登录 联网 有线和USB网络共享 1dhcpcd &lt;网卡型号&gt; 无线 12wifi-menudhcpcd &lt;网卡型号&gt; 添加用户 123useradd -m -G wheel,adm -s /bin/bash lanan # aaron替换为你喜欢的用户名, 不能大写passwd lanan # 设置用户密码EDITOR=vim visudo 这时会进入vim的操作界面, 取消# %wheel ALL=(ALL) ALL的注释即删除那个#号即可 启用32位支持、添加Archlinuxcn源和aur helper 启用32位支持, 即启用archlinux的[multilib], 它里面有一些32位程序, 如steam, wine等；启用很简单, 取消/etc/pacman.conf相应的注释即可 1234#[multilib]#Include = /etc/pacman.d/mirrorlist#Color#VerbosePkgLists 取消Color的注释可以让pacman彩色输出, 而VerbosePkgLists则是升级软件时, 可以查看新旧软件对比 添加Archlinuxcn社区源, 里面打包了aur上国人常用软件和一些软件的Linux版本, 在/etc/pacman.conf中加入 123[archlinuxcn]SigLevel = TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 可自行替换其他镜像源 再使用pacman -Syy archlinuxcn-keyring安装该源所需的密钥 ps：有时添加密钥出错, 可进行如下操作 12345rm -rf /etc/pacman.d/gnupgpacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcnpacman -Syy archlinuxcn-keyring aur helper可以让你快速便捷地安装aur上的软件, yay是用Go语言写的, 操作与pacman类似的aur helper, 在archlinuxcn源中就有 1pacman -S yay # 即可 安装Xorg服务 Xorg服务 1pacman -S xorg 只需安装该软件包组即可 触摸板驱动 在KDE上需要xf86-input-synaptics来设置触摸板, 而gnome使用xf86-input-libinput即可统一管理输入设备 12345pacman -S xf86-input-libinput xf86-input-synaptics ln -sf /usr/share/X11/xorg.conf.d/40-libinput.conf \\/etc/X11/xorg.conf.d/40-libinput.conf # 初始化输入设备配置ln -sf /usr/share/X11/xorg.conf.d/70-synaptics.conf \\/etc/X11/xorg.conf.d/70-synaptics.conf # 初始化触摸板配置 安装显卡驱动 intel核显开源驱动 intel开源驱动已经在kernel中集成, 即modesetting,但要确保内核参数中没有nomodeset或vga= xf86-video-intel是Xorg上的intel显卡驱动, 可不安装, 它提供了Xorg上的2D加速服务, 但arch wiki上不建议安装该驱动, 可能在一些显卡上有问题, 若需安装, 也请使用modesetting提供驱动 mesa提供了3D加速的DRI驱动和OpenGL支持, lib32-mesa为32位应用提供该支持, vulkan-intel提供vulkan支持, intel-media-driver提供VA-API视频硬件加速支持（&gt;=Broadwell） 1pacman -S mesa vulkan-intel intel-media-driver 还需设置LIBVA_DRIVER_NAME环境变量才可启用VA-API视频硬件加速支持 12echo 'export LIBVA_DRIVER_NAME=iHD' &gt; /etc/profile.d/va-api.shchmod a+x /etc/profile.d/va-api.sh NVIDIA独显闭源驱动 lts内核安装nvidia-lts, 需要使用图形界面设置可安装nvidia-settings, 提供VDPAU视频硬件加速和其他特性可安装nvidia-utils 1pacman -S nvidia-lts nvidia-settings nvidia-utils 双显卡笔记本可采用optimus-manager来管理, 具体可见Arch Wiki 1pacman -S optimus-manager optimus-manager-qt nvidia-prime 关于视频硬件加速, 可在vlc中启用, 有VA-API和VDPAU两种, 其中VDPAU是NVIDIA提供的, 使用N卡才会有 安装KDE1234pacman -S plasma kdebase kdegraphics # 安装KDE桌面和部分工具pacman -S sddm sddm-kcm # 安装KDE登录界面pacman -S latte-dock # KDE上好用的dock栏systemctl enable sddm # 设置登录界面自启动 安装网络管理模块和挂载MTP工具 网络管理 12pacman -S networkmanagersystemctl enable NetworkManager # 设置网络管理模块自启动 注意大小写 蓝牙管理 1234pacman -S bluez bluez-utils pulseaudio-modules-btpacman -S alsa-utils alsa-firmware alsa-plugins pulseaudio-alsausermod -aG lp aaron # 添加用户到lp组以控制蓝牙systemctl enable bluetooth # 设置蓝牙模块开机自启动 pulseaudio-modules-bt提供了蓝牙耳机或音箱的输出支持, 博通的蓝牙芯片需要再aur中加装驱动比如bluez-firmware MTP 12pacman -S libmtp mtpfspacman -S android-tools android-udev # 可选, 使用adb管理手机 若果用Gnome类的文件管理器, 可以安装gvfs-mtp, KDE的话, 安装kio-extras获得更好体验 重启即可看到图形界面 安装中文字体 使用fontconfig 我个人使用了fontconfig来让字体更好的渲染, 我用到的是noto-fonts、noto-fonts-cjk、noto-fonts-emoji和FuraCode-Nerd-Font, 前面三个archlinuxcn源有打包, 最后一个我是在nerd-font项目上下载的, 主要来使用zsh主题, 个人的fontconfig借鉴了Linux下的字体调校指南上的配置, 在dotfiles文件夹里 1sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji 将font.conf扔进个人home中的.config/fontconfig中重新登录即可看到效果 不使用fontconfig 推荐安装思源系列字体, 在KDE中设置即可 1sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts 更改语言1sudo sh -c \"echo 'LANG=zh_CN.UTF-8' &gt; /etc/locale.conf\" 重新登录即可 安装中文输入法 fcitx &amp; google-pinyin 1234sudo pacman -S fcitx fcitx-configtool fcitx-im fcitx-googlepinyin kcm-fcitxecho 'export GTK_IM_MODULE=fcitx' &gt; .xprofileecho 'export QT_IM_MODULE=fcitx' &gt;&gt; .xprofileecho 'export XMODIFIERS=@im=fcitx' &gt;&gt; .xprofile 经典的fcitx输入法框架 fcitx5 &amp; 中州韵(fcitx-rime)输入引擎 12345sudo pacman -S fcitx5-git fcitx5-gtk-git fcitx5-qt5-git fcitx5-rime-git kcm-fcitx5-git fcitx5-chinese-addons-gitecho 'export GTK_IM_MODULE=fcitx5' &gt; .xprofileecho 'export QT_IM_MODULE=fcitx5' &gt;&gt; .xprofileecho 'export XMODIFIERS=@im=fcitx5' &gt;&gt; .xprofileecho 'fcitx5 &amp;' &gt;&gt; .xprofile fcitx5是下一代fcitx输入法框架, 相关软件在archlinuxcn源中 重启后生效 安装TLP笔记本电源管理系统12345sudo pacman -S tlp tlp-rdw ethtool smartmontools # 安装TLPsudo systemctl enable tlp.servicesudo systemctl enable tlp-sleep.service # 设置TLP自启动sudo systemctl mask systemd-rfkill.servicesudo systemctl mask systemd-rfkill.socket # 屏蔽部分服务以免冲突 重启后生效 参考链接 ArchLinux’s General recommendations ArchLinux’s General recommendations中文译版 Linux下的字体调教指南 Linux下终极字体配置方案 oh-my-arch","categories":[],"tags":[{"name":"Archlinux","slug":"Archlinux","permalink":"http://yoursite.com/tags/Archlinux/"},{"name":"Install","slug":"Install","permalink":"http://yoursite.com/tags/Install/"}]},{"title":"Arch Linux Install","slug":"Arch-Linux-Install","date":"2020-01-26T12:13:53.000Z","updated":"2020-02-11T09:18:06.493Z","comments":true,"path":"2020/01/26/Arch-Linux-Install/","link":"","permalink":"http://yoursite.com/2020/01/26/Arch-Linux-Install/","excerpt":"Arch Linux 折腾日常之基本系统的安装Arch Linux是我最喜欢的发行版之一, 它接近上游, 可以体验到最新的软件包；系统可以自行定制却没LFS那么折腾, 我这样对Linux晓得一点皮毛的人也可以上手, 但这也可能是我无法发挥Arch的威力的原因。@~@ 我的配置：技嘉笔记本AORUS-15-X9,因为它物理屏蔽核显,导致我研究了好久,呜呜呜呜呜呜。在这篇博客中我将介绍无论是否屏蔽核显都通用的方法,下面正式开始 安装前的准备将archlinux的iso烧录到U盘 123sudo umount /dev/sdX* # 卸载U盘sudo dd if=./archlinux.iso of=/dev/sdX \\oflag=sync status=progress bs=4M # 烧录iso","text":"Arch Linux 折腾日常之基本系统的安装Arch Linux是我最喜欢的发行版之一, 它接近上游, 可以体验到最新的软件包；系统可以自行定制却没LFS那么折腾, 我这样对Linux晓得一点皮毛的人也可以上手, 但这也可能是我无法发挥Arch的威力的原因。@~@ 我的配置：技嘉笔记本AORUS-15-X9,因为它物理屏蔽核显,导致我研究了好久,呜呜呜呜呜呜。在这篇博客中我将介绍无论是否屏蔽核显都通用的方法,下面正式开始 安装前的准备将archlinux的iso烧录到U盘 123sudo umount /dev/sdX* # 卸载U盘sudo dd if=./archlinux.iso of=/dev/sdX \\oflag=sync status=progress bs=4M # 烧录iso 启动到Live CD插入U盘, 启动到archlinux的Live CD ps：N卡最好在启动时按下e并在末尾加入 “modprobe.blacklist=nouveau” 以禁用 nouveau 开源驱动, 否则可能花屏或者出现其他莫名bug 验证启动模式1ls /sys/firmware/efi/efivars 如果有结果, 系统就是以UEFI模式启动的, 否则是BIOS模式启动的, 我的笔记本是UEFI模式启动 联网可以用ip link查看自己的网卡型号, en打头的是有线, 比如宽带或者手机USB网络共享, wl打头是无线网卡的型号。我的笔记本在archlinux的Live CD下可以看到eno1和wlan0 有线 插了网线的的启动Live CD时就会用dhcpcd获取有线的ip地址, 也可以ping一下百度测试一下 无线 123wifi-menu # 连接wifidhcpcd wlan0 # 获取ip地址ping -c4 www.baidu.com # 测试连接 wlan0 替换为你自己的无线网卡型号就行 USB网络共享 1dhcpcd &lt;网卡型号&gt; # 即可自动获取ip地址 更换软件源1vim /etc/pacman.d/mirorrlist 这个mirrorlist在会复制到接下来安装的系统中, 我在第一行加入了下面的(东软)镜像源, 可自行更换 1Server = https://mirrors.neusoft.edu.cn/archlinux/$repo/os/$arch 更新系统时间12timedatectl set-ntp truetimedatectl status # 可选, 查看系统现在的时间状态 分区 我的分区方案： 挂载点 分区类型 大小 文件系统 /boot/efi EFI系统分区(EF00) 512MB fat32 / Linux 根目录(8300) 50GB xfs /home 个人数据目录(8300) 200GB xfs [SWAP] Linux swap交换分区(8200) 4GB swap GPT分区表最好使用 gdisk 命令或者 cgdisk 交互命令 1gdisk /dev/nvme0n1 # 更换为自己想要安装到的硬盘 nvme一般是m.2接口的硬盘, sata的硬盘可能是sda、sdb什么的 分完区可以用 lsblk 命令检查一下 格式化和挂载分区 123456789mkfs.fat -F32 /dev/nvme0n1p1 # 格式化efi分区mkfs.xfs /dev/nvme0n1p2 # 格式化root分区mkfs.xfs /dev/nvme0n1p3 # 格式化home分区mkswap /dev/nvme0n1p4 # 格式化swap分区swapon /dev/nvme0n1p4 # 启用swapmount /dev/nvme0n1p2 /mnt # 把root分区挂载到/mntmkdir -p /mnt/boot/efi /mnt/home # 建立/boot/efi和/home目录mount /dev/nvme0n1p1 /mnt/boot/efi # 挂载efi分区到/boot/efimount /dev/nvme0n1p3 /mnt/home # 挂载home分区到/home 开始安装123pacstrap /mnt base base-devel linux-lts linux-lts-headers linux-firmware\\dosfstools xfsprogs sysfsutils inetutils net-tools dhcpcd netctl iw wpa_supplicant dialog\\less vim man-db man-pages bash-completion base组更改之后需要加装很多东西, 管理文件系统的、联网的、文本编辑的…… 基本系统：base、base-devel 其中base-devel包含很多开发所需工具 Linux内核：linux-lts、linux-lts-headers, 我安装的是LTS的Linux, bug会少一些, ArchLinux中有许多为不是使用主线稳定内核的用户提供dkms版的软件, 需要内核对应的headers来安装 大部分驱动：linux-firmware 管理文件系统：xfsprogs、dosfstool、sysfsutils, 管理xfs、fat32等文件系统 网络连接所需工具：inetutils、net-tools、dhcpcd、netctl、iw、wpa_supplicant、dialog 来管理有线和无线连接 文本浏览和编辑工具：less、vim man系统手册：man-db、man-pages 为了等下可以补全部分命令安装bash-completion 配置系统 Fstab 生成fstab文件 1genfstab -U /mnt &gt;&gt; /mnt/etc/fstab 建议用vim查看一下生成后的fstabvim /mnt/etc/fstab Chroot Change root 到刚刚安装的系统 1arch-chroot /mnt 本地化 时区 123ln -sf /usr/share/zoneinfo/Asia/Shanghai \\/etc/localtime # 更改时区hwclock --systohc # 应用到硬件时间 语言 1vim /etc/locale.gen 移除下列语言的注释(#)即可 12en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8 12locale-genecho 'LANG=en_US.UTF-8' &gt; /etc/locale.conf 生成语言信息, 然后更改语言环境为英文, 避免乱码 网络配置 12echo 'AORUS-X9' &gt; /etc/hostnamevim /etc/hosts AORUS-X9是我自己的主机名, 自己更改为喜欢的名字即可, 下面的主机名也要随着该 加入以下内容 123127.0.0.1 localhost::1 localhost127.0.1.1 AORUS-X9.localdomain AORUS-X9 Initramfs 12pacman -Syy intel-ucode # 安装intel微码mkinitcpio -p linux-lts # 生成initramfs 设定Root密码 1passwd # 即可 安装引导1234pacman -S grub efibootmgr os-probergrub-install --target=x86_64-efi --efi-directory=/boot/efi \\--bootloader-id=GRUB_ARCH --recheck # 安装grub引导grub-mkconfig -o /boot/grub/grub.cfg # 生成grub配置 若是多系统, 需要将其他系统的efi分区挂载, 然后再使用上述最后一条命令重新生成grub配置即可 ####安装暂时用的NVIDIA驱动(选做) 1pacman -S nvidia-lts 因为我的笔记本屏蔽了核显,因此需要安装NVIDIA驱动才能在下一步的重启后不花屏,下篇文章会介绍安装完整的NVIDIA驱动 重启123exitumount -a # 卸载已挂载的文件系统reboot 若是N卡, 建议在重启启动时grub中按e添加参数, 在linux所在行行尾添加 “modprobe.blacklist=nouveau”再按Ctrl + x启动即可 参考链接 ArchLinux‘s Install Guide [ArchLinux’s Install Guide中文译版 oh-my-arch","categories":[],"tags":[{"name":"Archlinux","slug":"Archlinux","permalink":"http://yoursite.com/tags/Archlinux/"},{"name":"Install","slug":"Install","permalink":"http://yoursite.com/tags/Install/"}]},{"title":"Cpp-Primer第一章练习","slug":"Cpp-Primer第一章练习","date":"2020-01-26T10:15:23.000Z","updated":"2020-02-11T09:18:06.493Z","comments":true,"path":"2020/01/26/Cpp-Primer第一章练习/","link":"","permalink":"http://yoursite.com/2020/01/26/Cpp-Primer%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%83%E4%B9%A0/","excerpt":"Chapter one exercises (正在更新)exercise-1.1 123int main() &#123; return 0;&#125;","text":"Chapter one exercises (正在更新)exercise-1.1 123int main() &#123; return 0;&#125; exercise-1-2","categories":[],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://yoursite.com/tags/C-Primer/"},{"name":"练习","slug":"练习","permalink":"http://yoursite.com/tags/%E7%BB%83%E4%B9%A0/"}]},{"title":"2020跨年文案","slug":"2020跨年文案","date":"2020-01-24T15:59:59.000Z","updated":"2020-02-11T09:18:06.493Z","comments":true,"path":"2020/01/24/2020跨年文案/","link":"","permalink":"http://yoursite.com/2020/01/24/2020%E8%B7%A8%E5%B9%B4%E6%96%87%E6%A1%88/","excerpt":"","text":"Happy 2020走到一年的尾巴上时，总有一种奇异心绪。 一方面，总觉得又是虚度了三百日光阴，仍然没有什么长进。另一方面，又劝说自己可以做的不好也没有什么，大不了及时清零，2020年再去“收拾旧山河”。我不知道会不会有朝一日，我变得不再奢望，安于现状。 但至少，要在彻底沦为庸庸碌碌之前，打磨出更多些的光亮。 2020年，我还想试试。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"}]}]}